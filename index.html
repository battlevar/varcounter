<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mind‑Blower: WebGL Fractalverse — Bloom, Godrays, Orbits, No‑Roll Cam + Kaleidoscope</title>
<style>
  html, body { height:100%; margin:0; background:#000; overflow:hidden; }
  #gl { width:100vw; height:100vh; display:block; }
  #hud { position:fixed; left:12px; top:12px; color:#eee; font:12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:rgba(0,0,0,.35); backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; max-width: min(740px, 82vw); pointer-events:none; white-space:pre-wrap; user-select:none; }
  #hud b { color:#fff }
  #badges { position:fixed; right:12px; bottom:12px; display:flex; flex-wrap:wrap; gap:8px; }
  .chip { color:#ddd; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.1); padding:6px 10px; border-radius:999px; font:11px/1 system-ui; }
  #err { position:fixed; left:12px; bottom:12px; right:12px; color:#f99; background:rgba(60,0,0,.65); border:1px solid rgba(255,80,80,.35); border-radius:10px; padding:10px; font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; display:none; max-height:38vh; overflow:auto; }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div id="hud"></div>
<div id="badges">
  <div class="chip">Click → lock cursor</div>
  <div class="chip">Mouse‑look (no roll)</div>
  <div class="chip">WASD move • Q/E down/up • Shift sprint</div>
  <div class="chip">Wheel = FOV • Space turbo</div>
  <div class="chip">1 Psychedelic • 2 Shadows • 3 AO • 4 FOV</div>
  <div class="chip">5 Lensing • 6 Bloom/Godrays • 7 ChromAb • 8 Kaleido</div>
  <div class="chip">T Trails • P Pause orbits • I Intensity • R Reset • K Screenshot • M Mute</div>
</div>
<pre id="err"></pre>
<script>
'use strict';
(() => {
  const canvas = document.getElementById('gl');
  const hud = document.getElementById('hud');
  const err = document.getElementById('err');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // WebGL2 setup
  /** @type {WebGL2RenderingContext} */
  const gl = canvas.getContext('webgl2', { antialias:false, depth:false, stencil:false, powerPreference:'high-performance', preserveDrawingBuffer:false });
  if(!gl){ showError('WebGL2 not supported by this browser/device. Try Chrome/Edge/Firefox on desktop.'); return; }

  // Resize & targets
  let sceneFBO, sceneTex, blurFBOA, blurTexA, blurFBOB, blurTexB, historyFBO, historyTex;
  function createTex(w,h){
    const t = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    return t;
  }
  function createFBO(tex){ const fb = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fb); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); return fb; }

  function fit(){
    const w = Math.max(2, Math.floor(window.innerWidth * DPR));
    const h = Math.max(2, Math.floor(window.innerHeight * DPR));
    canvas.width = w; canvas.height = h; canvas.style.width = '100vw'; canvas.style.height = '100vh'; gl.viewport(0,0,w,h);
    // (Re)alloc targets
    [sceneTex, blurTexA, blurTexB, historyTex].forEach(t=> t && gl.deleteTexture(t));
    [sceneFBO, blurFBOA, blurFBOB, historyFBO].forEach(f=> f && gl.deleteFramebuffer(f));
    sceneTex = createTex(w,h); sceneFBO = createFBO(sceneTex);
    const hw = Math.max(2, w>>1), hh = Math.max(2, h>>1);
    blurTexA = createTex(hw, hh); blurFBOA = createFBO(blurTexA);
    blurTexB = createTex(hw, hh); blurFBOB = createFBO(blurTexB);
    historyTex = createTex(w,h); historyFBO = createFBO(historyTex);
  }
  window.addEventListener('resize', ()=>{ DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); fit(); }); fit();

  // ───────────────────────────── Vertex Shader ─────────────────────────────
  const vert = `#version 300 es
  layout(location=0) in vec2 pos; out vec2 vUv; void main(){ vUv = pos*0.5+0.5; gl_Position = vec4(pos,0.0,1.0);} `;

  // ───────────────────────────── Raymarch Shader ─────────────────────────────
  const fragRay = `#version 300 es
  precision highp float; precision highp int;
  out vec4 fragColor; in vec2 vUv;
  uniform vec2 iResolution; uniform float iTime; uniform mat3 camR; uniform vec3 camP; uniform float camFov;
  uniform int uShadowOn; uniform int uAOOn; uniform int uPsycho; uniform int uLens; // black hole lens
  uniform float uAudioL; uniform float uAudioH; // audio reactivity
  uniform int uPauseOrbits;

  #define SUNDIR normalize(vec3(0.6, 0.5, 0.2))

  float hash11(float p){ return fract(sin(p*127.1)*43758.5453123); }
  float hash21(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7)))*43758.5453); }
  float vnoise(vec3 x){ vec3 P=floor(x), F=fract(x); F=F*F*(3.0-2.0*F); float n=dot(P,vec3(1.0,57.0,113.0)); float a=hash11(n+0.0); float b=hash11(n+1.0); float c=hash11(n+57.0); float d=hash11(n+58.0); float e=hash11(n+113.0); float f1=mix(a,b,F.x); float f2=mix(c,d,F.x); float f3=mix(e,hash11(n+114.0),F.x); return mix(mix(f1,f2,F.y), mix(f2,f3,F.y), F.z); }
  float fbm(vec3 p){ float a=0.0,amp=0.5; for(int i=0;i<5;i++){ a+=amp*vnoise(p); p*=2.02; amp*=0.5;} return a; }

  float sdPlane(vec3 p){ return p.y + 1.5; }
  float sdBox(vec3 p, vec3 b){ vec3 q=abs(p)-b; return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0); }

  float deMandelbulb(vec3 pos, out float trap, out float iter){
    vec3 z=pos; float dr=1.0; float r=0.0; trap=1e9; iter=0.0; const float Power=8.0; const int IT=10;
    for(int i=0;i<IT;i++){ r=length(z); trap=min(trap,r); if(r>2.5){ iter=float(i); break; }
      float theta=acos(z.z/(r+1e-8)); float phi=atan(z.y,z.x); dr=pow(r,Power-1.0)*Power*dr+1.0; float zr=pow(r,Power); theta*=Power; phi*=Power;
      z = zr*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));
      z += pos + 0.12*vec3(sin(iTime*0.5), 0.0, cos(iTime*0.43));
    }
    return 0.5*log(r)*r/dr;
  }

  struct Hit{ float d; int mat; float trap; float it; };

  Hit map(vec3 p){
    vec3 q=p; float t=(uPauseOrbits==1? 0.0 : iTime)*(0.8+0.6*uAudioL); float ang=0.15*sin(t*0.23); mat2 R=mat2(cos(ang),-sin(ang), sin(ang),cos(ang));
    q.xz = R*(q.xz + 0.42*vec2(sin(t*0.16), cos(t*0.11)));
    q.xz = mod(q.xz + 4.0, 8.0) - 4.0; // tile extension

    float trap,it; float dF=deMandelbulb(q*0.85, trap,it);
    float dP=sdPlane(p);
    float dB=sdBox(p-vec3(0.0, 0.2+0.3*sin(iTime*0.5), 0.0), vec3(2.2, 0.02, 2.2));
    Hit h; h.d=dF; h.mat=1; h.trap=trap; h.it=it; if(dP<h.d){ h.d=dP; h.mat=2; } if(dB<h.d){ h.d=dB; h.mat=3; } return h;
  }

  vec3 getNormal(vec3 p){ const vec2 e=vec2(1.0,-1.0)*0.5773; float h=0.0008; return normalize( e.xyy*map(p+e.xyy*h).d + e.yyx*map(p+e.yyx*h).d + e.yxy*map(p+e.yxy*h).d + e.xxx*map(p+e.xxx*h).d ); }
  float softShadow(vec3 ro, vec3 rd, float k){ float res=1.0; float t=0.02; for(int i=0;i<64;i++){ Hit h=map(ro+rd*t); float d=h.d; res=min(res, k*d/t); t+=clamp(d,0.01,0.2); if(res<0.001||t>30.0) break; } return clamp(res,0.0,1.0); }
  float AO(vec3 p, vec3 n){ float occ=0.0, sca=1.0; for(int i=0;i<5;i++){ float h=0.01+0.12*float(i); float d=map(p+n*h).d; occ+=(h-d)*sca; sca*=0.6;} return clamp(1.0-1.5*occ,0.0,1.0);} 

  vec3 skyColor(vec3 rd){ float t=clamp(rd.y*0.5+0.5,0.0,1.0); vec3 zen=mix(vec3(0.02,0.04,0.07), vec3(0.13,0.20,0.32), t); vec3 hor=vec3(0.18,0.16,0.14); return mix(hor,zen,smoothstep(0.0,0.8,t)); }
  vec3 tonemapACES(vec3 x){ const float a=2.51,b=0.03,c=2.43,d=0.59,e=0.14; return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0); }
  vec3 palette(float x){ if(uPsycho==0) return vec3(0.55+0.45*cos(6.28318*(x+vec3(0.0,0.15,0.33)))); return 0.5+0.5*cos(6.28318*(x*vec3(1.0,0.77,0.55)+vec3(0.0,0.33,0.67)+iTime*0.1)); }

  vec3 planetColor(vec3 rd, vec3 cdir, float arad, vec3 base, float ring){
    float cd=dot(rd,cdir); float m=smoothstep(cos(arad), cos(arad*0.98), cd); if(m<=0.0) return vec3(0.0);
    vec3 up=(abs(cdir.y)<0.99)? vec3(0.0,1.0,0.0): vec3(1.0,0.0,0.0); vec3 tx=normalize(cross(up,cdir)); vec3 ty=cross(cdir,tx);
    float u=dot(rd,tx), v=dot(rd,ty); float w=cd; float ang=acos(clamp(w,-1.0,1.0)); float rr=clamp(ang/arad,0.0,1.0); float phi=atan(v,u);
    float bands=0.5+0.5*sin(phi*8.0+rr*12.0+iTime*0.2);
    float storms=0.3+0.7*smoothstep(0.2,1.0, vnoise(vec3(u*5.0,v*5.0,iTime*0.1)));
    vec3 col = base * mix(0.7,1.6,bands) * mix(0.7,1.2,storms);
    float ndl=clamp(dot(cdir,SUNDIR),0.0,1.0); float limb=pow(1.0-rr,0.25); col *= (0.35+0.65*ndl) * (0.6+0.4*limb);
    float spec=pow(max(dot(reflect(-SUNDIR,cdir),rd),0.0),128.0); col += vec3(1.0,0.95,0.9)*spec*0.25;
    if(ring>0.0){ float ringAng = abs(dot(rd,ty)); float ringMask = smoothstep(cos(arad*1.2), cos(arad*1.02), dot(rd,cdir)); ringMask *= smoothstep(0.02,0.0,ringAng);
      float ringBands = 0.5+0.5*sin(120.0*phi); col += vec3(0.9,0.8,0.6)*ring*ringBands*ringMask*0.6; }
    col += vec3(0.18,0.30,0.52) * pow(1.0-rr, 2.5) * 0.25;
    return col*m;
  }

  vec3 lensRD(vec3 ro, vec3 rd, vec3 bhC){
    vec3 rel = bhC - ro; float b = length(cross(rd, rel));
    float k = 0.055; float alpha = k / (b + 0.15); vec3 axis = normalize(cross(rd, rel));
    float ca=cos(alpha), sa=sin(alpha); return (ca*rd) + (sa*cross(axis, rd)) + ((1.0-ca)*dot(axis, rd))*axis;
  }

  void main(){
    vec2 uv = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;
    float fov = radians(camFov);
    vec3 rd = normalize(camR * normalize(vec3(uv * tan(fov*0.5)*2.0, -1.0)) );
    vec3 ro = camP;

    if(uLens==1){ rd = lensRD(ro, rd, vec3(2.5, 0.6, 0.0)); }

    float t=0.0; float mIt=0.0; float trap=0.0; int mat=0; bool hit=false; vec3 p;
    for(int i=0;i<200;i++){ p=ro+rd*t; Hit h=map(p); mat=h.mat; trap=h.trap; mIt=h.it; float d=h.d; if(d<0.001){ hit=true; break;} t+=d; if(t>60.0) break; }

    vec3 col; 
    if(!hit){
      vec3 sky=skyColor(rd); float tt=iTime;
      vec3 d1=normalize(vec3(cos(tt*0.07)*0.6, 0.18 + 0.12*sin(tt*0.11), sin(tt*0.07)));
      vec3 d2=normalize(vec3(cos(-tt*0.11+2.1)*-0.8, -0.05 + 0.2*sin(tt*0.09+1.3), sin(-tt*0.11+2.1)));
      vec3 p1=planetColor(rd,d1, radians(18.0), vec3(0.85,0.78,0.95), 0.0);
      vec3 p2=planetColor(rd,d2, radians(12.0), vec3(0.95,0.88,0.68), 1.0);
      float sun=pow(max(dot(rd,SUNDIR),0.0), 1024.0);
      col = sky + p1 + p2 + vec3(1.0,0.9,0.7)*sun*0.9;
    } else {
      vec3 n=getNormal(p); float ao=(uAOOn==1)?AO(p,n):1.0; float sh=(uShadowOn==1)?softShadow(p+n*0.001,SUNDIR,24.0):1.0;
      float ndl=max(dot(n,SUNDIR),0.0); float ndv=max(dot(n,-rd),0.0);
      if(mat==1){ float h=clamp(1.0-trap*0.7,0.0,1.0); vec3 base=palette(0.15+0.02*mIt + h*0.6 + uAudioH*0.1);
        vec3 irid=0.4+0.6*palette(0.6 + 3.0*dot(n, normalize(vec3(0.2,1.0,0.4))));
        vec3 diff=base*(0.25+0.75*ndl)*sh; vec3 spec=pow(max(dot(reflect(-SUNDIR,n),-rd),0.0),64.0)*vec3(1.0,0.95,0.9); vec3 amb=skyColor(n)*0.6*ao; col=diff+spec*0.5+amb*0.8+0.25*irid*h;
      } else if(mat==2){ vec2 uvp=p.xz*0.6; float m=fbm(vec3(uvp*1.2,0.0)); float ridges=pow(fbm(vec3(uvp*3.0+10.0,0.0)),2.0);
        vec3 rockA=vec3(0.10,0.11,0.12), rockB=vec3(0.24,0.22,0.20); vec3 base=mix(rockA,rockB, smoothstep(0.2,0.95,m))+ridges*vec3(0.08,0.06,0.05);
        vec3 diff=base*(0.15+0.85*ndl)*sh; vec3 amb=vec3(0.08,0.09,0.10)*ao; col=diff+amb;
      } else { vec3 base=vec3(0.9,0.85,0.7); vec3 diff=base*(0.2+0.8*ndl)*sh; vec3 amb=vec3(0.1,0.12,0.15)*ao; col=diff+amb; }
      float fog=1.0-exp(-0.008*t); col=mix(col, skyColor(rd), fog); col += 0.25*pow(1.0-ndv,3.0);
    }

    float luma = dot(col, vec3(0.2126,0.7152,0.0722));
    float mask = smoothstep(0.75, 1.2, luma);
    fragColor = vec4(tonemapACES(col*1.6), mask);
  }
  `;

  // ───────────────────────────── Blur Shader (Kawase-ish) ─────────────────────────────
  const fragBlur = `#version 300 es
  precision highp float; out vec4 fragColor; in vec2 vUv; uniform sampler2D uTex; uniform vec2 uTexel; uniform float uRadius;
  void main(){
    vec2 o = uTexel * uRadius; vec3 c = texture(uTex, vUv).rgb * 0.227027;
    c += texture(uTex, vUv + vec2( o.x, 0.0)).rgb * 0.316216;
    c += texture(uTex, vUv + vec2(-o.x, 0.0)).rgb * 0.316216;
    c += texture(uTex, vUv + vec2( 0.0,  o.y)).rgb * 0.070270;
    c += texture(uTex, vUv + vec2( 0.0, -o.y)).rgb * 0.070270;
    fragColor = vec4(c,1.0);
  }
  `;

  // ───────────────────────────── Composite Shader (bloom+godrays+chromab+trails+kaleido) ─────────────────────────────
  const fragFinal = `#version 300 es
  precision highp float; out vec4 fragColor; in vec2 vUv;
  uniform sampler2D uScene; uniform sampler2D uBloom; uniform sampler2D uHistory; uniform vec2 uRes;
  uniform float iTime; uniform float camFov; uniform mat3 camR; uniform int uBloomOn; uniform int uChromAb; uniform int uGodraysOn; uniform int uTrailsOn; uniform int uKaleido; uniform float uIntensity;

  #define SUNDIR normalize(vec3(0.6, 0.5, 0.2))

  float maskAt(vec2 uv){ return texture(uScene, uv).a; }

  // Kaleidoscope mapping
  vec2 kaleido(vec2 uv, int sides, float twist){
    vec2 p = (uv - 0.5) * vec2(uRes.x/uRes.y, 1.0);
    float a = atan(p.y, p.x) + twist;
    float r = length(p);
    float sector = 6.28318530718 / float(max(1, sides));
    a = mod(a, sector);
    a = abs(a - sector*0.5);
    vec2 q = vec2(cos(a), sin(a)) * r;
    q *= vec2(uRes.y/uRes.x, 1.0);
    return q + 0.5;
  }

  vec3 chromab(vec2 uv){
    vec2 c = (uv - 0.5) * vec2(uRes.x/uRes.y, 1.0);
    vec2 shift = (0.0015 * (0.8 + 0.6*uIntensity)) * c * (0.9 + 0.6*sin(iTime*0.5));
    vec3 col;
    col.r = texture(uScene, uv + (uChromAb==1? shift : vec2(0))).r;
    col.g = texture(uScene, uv).g;
    col.b = texture(uScene, uv - (uChromAb==1? shift : vec2(0))).b;
    return col;
  }

  // Screen-space godrays from sun dir
  vec3 godrays(vec2 uv){
    vec3 sunCam = transpose(camR) * SUNDIR;
    float fov = radians(camFov);
    vec2 sunUv = ( (sunCam.xy / max(1e-3, -sunCam.z)) / (tan(fov*0.5)*2.0) ) * vec2(1.0, uRes.y/uRes.x) * 0.5 + 0.5;
    vec2 dir = (sunUv - uv);
    float d = length(dir);
    vec3 acc = vec3(0.0);
    vec2 step = dir / 48.0;
    vec2 p = uv;
    for(int i=0;i<48;i++){ p += step; float m = maskAt(p); acc += vec3(m); acc *= 0.975; }
    float fall = smoothstep(0.9, 0.0, d);
    return acc * 0.02 * fall;
  }

  void main(){
    vec2 uv = vUv;
    if(uKaleido==1){ int sides = int(6.0 + 6.0*uIntensity); float tw = 0.25*sin(iTime*0.2); uv = kaleido(uv, sides, tw); }

    vec3 base = chromab(uv);
    vec3 bloom = texture(uBloom, uv).rgb * (0.9 + 0.6*uIntensity);
    vec3 rays = (uGodraysOn==1) ? godrays(uv) : vec3(0.0);

    vec3 col = base + (uBloomOn==1? bloom*1.2 : vec3(0.0)) + rays;

    if(uTrailsOn==1){ vec3 prev = texture(uHistory, uv).rgb; float mixAmt = 0.80 + 0.15*clamp(uIntensity,0.0,1.0); col = mix(col, prev, mixAmt); }

    vec2 c = uv - 0.5; float r2 = dot(c,c);
    col *= smoothstep(0.92, 0.28, r2);
    float grain = fract(sin(dot(uv*vec2(uRes), vec2(12.9898,78.233)) + iTime*43758.5453));
    col += (grain-0.5) * 0.02;

    fragColor = vec4(col,1.0);
  }
  `;

  // ───────────────────────────── Compile/Link ─────────────────────────────
  function showError(msg){ err.style.display='block'; err.textContent=String(msg); console.error(msg); }
  function compile(type, src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ const log=gl.getShaderInfoLog(s)||'(empty)'; showError((type===gl.VERTEX_SHADER?'VERTEX':'FRAG')+' COMPILE ERROR\n\n'+log); throw new Error('Shader compile failed'); } return s; }
  function link(vs, fs){ const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.bindAttribLocation(p,0,'pos'); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ const log=gl.getProgramInfoLog(p)||'(empty)'; showError('PROGRAM LINK ERROR\n\n'+log); throw new Error('Program link failed'); } return p; }

  const progRay = link(compile(gl.VERTEX_SHADER, vert), compile(gl.FRAGMENT_SHADER, fragRay));
  const progBlur = link(compile(gl.VERTEX_SHADER, vert), compile(gl.FRAGMENT_SHADER, fragBlur));
  const progFinal = link(compile(gl.VERTEX_SHADER, vert), compile(gl.FRAGMENT_SHADER, fragFinal));

  // ───────────────────────────── Fullscreen Quad ─────────────────────────────
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
  const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1 ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  // Uniform locations we need often
  const uRay = { iResolution:gl.getUniformLocation(progRay,'iResolution'), iTime:gl.getUniformLocation(progRay,'iTime'), camR:gl.getUniformLocation(progRay,'camR'), camP:gl.getUniformLocation(progRay,'camP'), camFov:gl.getUniformLocation(progRay,'camFov'), uShadowOn:gl.getUniformLocation(progRay,'uShadowOn'), uAOOn:gl.getUniformLocation(progRay,'uAOOn'), uPsycho:gl.getUniformLocation(progRay,'uPsycho'), uLens:gl.getUniformLocation(progRay,'uLens'), uAudioL:gl.getUniformLocation(progRay,'uAudioL'), uAudioH:gl.getUniformLocation(progRay,'uAudioH'), uPauseOrbits:gl.getUniformLocation(progRay,'uPauseOrbits') };
  const uBlur = { uTex:gl.getUniformLocation(progBlur,'uTex'), uTexel:gl.getUniformLocation(progBlur,'uTexel'), uRadius:gl.getUniformLocation(progBlur,'uRadius') };
  const uFin = { uScene:gl.getUniformLocation(progFinal,'uScene'), uBloom:gl.getUniformLocation(progFinal,'uBloom'), uHistory:gl.getUniformLocation(progFinal,'uHistory'), uRes:gl.getUniformLocation(progFinal,'uRes'), iTime:gl.getUniformLocation(progFinal,'iTime'), camFov:gl.getUniformLocation(progFinal,'camFov'), camR:gl.getUniformLocation(progFinal,'camR'), uBloomOn:gl.getUniformLocation(progFinal,'uBloomOn'), uChromAb:gl.getUniformLocation(progFinal,'uChromAb'), uGodraysOn:gl.getUniformLocation(progFinal,'uGodraysOn'), uTrailsOn:gl.getUniformLocation(progFinal,'uTrailsOn'), uKaleido:gl.getUniformLocation(progFinal,'uKaleido'), uIntensity:gl.getUniformLocation(progFinal,'uIntensity') };

  // ───────────────────────────── Self‑tests ("test cases") ─────────────────────────────
  const TESTS=[]; function addTest(name,fn){ try{ const out=fn(); TESTS.push({name,ok:true,out}); } catch(e){ TESTS.push({name,ok:false,err:String(e)}); } }
  addTest('Ray uniforms exist', ()=>{ for(const [k,v] of Object.entries(uRay)) if(v===null) throw new Error('Missing uniform: '+k); return 'OK'; });
  addTest('Blur/Final uniforms exist', ()=>{ for(const [k,v] of Object.entries(uBlur)) if(v===null) throw new Error('Missing blur uniform'); for(const [k,v] of Object.entries(uFin)) if(v===null) throw new Error('Missing final uniform '+k); return 'OK'; });
  addTest('Program link OK', ()=>{ if(!progRay||!progBlur||!progFinal) throw new Error('program missing'); return 'OK'; });
  addTest('FBO completeness', ()=>{ gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO); if(gl.checkFramebufferStatus(gl.FRAMEBUFFER)!==gl.FRAMEBUFFER_COMPLETE) throw new Error('sceneFBO incomplete'); return 'OK'; });

  // ───────────────────────────── Camera (no‑roll) ─────────────────────────────
  function cross(a,b){ return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ]; }
  function normalize(a){ const L=Math.hypot(a[0],a[1],a[2])||1; return [a[0]/L,a[1]/L,a[2]/L]; }
  function camMatrixNoRoll(yaw,pitch){ const sx=Math.sin(yaw), cx=Math.cos(yaw); const sp=Math.sin(pitch), cp=Math.cos(pitch); const f=[ sx*cp, sp, cx*cp ]; const upw=[0,1,0]; const r=normalize(cross(upw,f)); const u=cross(f,r); return [ r[0],r[1],r[2], u[0],u[1],u[2], -f[0],-f[1],-f[2] ]; }

  let yaw=Math.PI*0.25, pitch=0.12, fov=60, turbo=0; let pos={x:0,y:1.2,z:6.0};
  const keys=Object.create(null); let mouseLocked=false; let intensity=0.2;
  const toggles = { shadow:1, ao:1, psycho:0, lens:1, post:1, chromab:1, trails:0, pauseOrbits:0, kaleido:0 };

  // Input
  canvas.addEventListener('click', ()=>{ if(!mouseLocked&&canvas.requestPointerLock){ canvas.requestPointerLock(); startAudio(); } });
  document.addEventListener('pointerlockchange', ()=>{ mouseLocked=(document.pointerLockElement===canvas); });
  document.addEventListener('mousemove', e=>{ if(mouseLocked){ const sens=0.0020; yaw += e.movementX*sens; pitch -= e.movementY*sens; const lim=1.35; pitch=Math.max(-lim,Math.min(lim,pitch)); } });
  window.addEventListener('wheel', e=>{ e.preventDefault(); fov=Math.max(30, Math.min(90, fov + Math.sign(e.deltaY)*2)); }, {passive:false});
  window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Space'){ if(!e.repeat) turbo=turbo?0:1; e.preventDefault(); } handleHotkeys(e); });
  window.addEventListener('keyup', e=>{ keys[e.code]=false; });

  function handleHotkeys(e){
    if(e.key==='1') toggles.psycho^=1; if(e.key==='2') toggles.shadow^=1; if(e.key==='3') toggles.ao^=1; if(e.key==='4') fov=(fov>55?40:70);
    if(e.key==='5') toggles.lens^=1; if(e.key==='6') toggles.post^=1; if(e.key==='7') toggles.chromab^=1; if(e.key==='8') toggles.kaleido^=1; if(e.key==='t'||e.key==='T') toggles.trails^=1;
    if(e.key==='p'||e.key==='P') toggles.pauseOrbits^=1; if(e.key==='m'||e.key==='M') toggleMute(); if(e.key==='r'||e.key==='R') resetCam(); if(e.key==='k'||e.key==='K') screenshot(); if(e.key==='i'||e.key==='I') cycleIntensity();
  }
  function resetCam(){ yaw=Math.PI*0.25; pitch=0.12; pos={x:0,y:1.2,z:6.0}; intensity=1.0; }
  function cycleIntensity(){ intensity = (intensity>=2.0)? 0.6 : (intensity+0.7); }

  let fps=0; function drawHUD(){ hud.textContent = `⚡ Fractalverse — WASD/QE, Shift sprint, Wheel FOV | Space Turbo (${turbo?'ON':'off'})\n[1]Psy ${toggles.psycho?'ON':'off'}  [2]Shad ${toggles.shadow?'ON':'off'}  [3]AO ${toggles.ao?'ON':'off'}  [4]FOV ${fov.toFixed(0)}°  [5]Lensing ${toggles.lens?'ON':'off'}  [6]Post ${toggles.post?'ON':'off'}  [7]ChromAb ${toggles.chromab?'ON':'off'}  [8]Kaleido ${toggles.kaleido?'ON':'off'}  [T]Trails ${toggles.trails?'ON':'off'}\nIntensity ${intensity.toFixed(2)}  |  [M]Mute ${audioState.muted?'ON':'off'}  [P]Pause orbits ${toggles.pauseOrbits?'ON':'off'}  [R]Reset  [K]Screenshot\nFPS ${fps.toFixed(1)}  |  ${ (canvas.width*canvas.height/1e6).toFixed(2) } MPix`; }

  // ───────────────────────────── Audio (procedural pad + analyser) ─────────────────────────────
  const audioState = { ctx:null, analyser:null, data:null, muted:false };
  function startAudio(){ if(audioState.ctx) return; try{ const ctx=new (window.AudioContext||window.webkitAudioContext)(); const osc=ctx.createOscillator(); const osc2=ctx.createOscillator(); const gain=ctx.createGain(); const lfo=ctx.createOscillator(); const lfoGain=ctx.createGain();
      osc.type='sawtooth'; osc.frequency.value=110; osc2.type='triangle'; osc2.frequency.value=220;
      lfo.frequency.value=0.07; lfoGain.gain.value=30; lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
      const filt=ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=800;
      const analyser=ctx.createAnalyser(); analyser.fftSize=1024; const data=new Uint8Array(analyser.frequencyBinCount);
      gain.gain.value=0.08; osc.connect(filt); osc2.connect(filt); filt.connect(gain); gain.connect(analyser); analyser.connect(ctx.destination);
      osc.start(); osc2.start(); lfo.start(); audioState.ctx=ctx; audioState.analyser=analyser; audioState.data=data; }
    catch(e){ console.warn('Audio init failed', e); }
  }
  function toggleMute(){ if(!audioState.ctx) return; audioState.muted=!audioState.muted; audioState.ctx.destination.gain ? (audioState.ctx.destination.gain.value= audioState.muted?0:1) : null; }
  function getAudio(){ let low=0, hi=0; const an=audioState.analyser; if(an){ an.getByteFrequencyData(audioState.data); const N=audioState.data.length; for(let i=2;i<16&&i<N;i++) low+=audioState.data[i]; for(let i=96;i<256&&i<N;i++) hi+=audioState.data[i]; low/=14*255; hi/=160*255; } return {low,hi}; }

  // Screenshot
  function screenshot(){ const a=document.createElement('a'); a.download='fractalverse.png'; a.href=canvas.toDataURL('image/png'); a.click(); }

  // Render loop
  let lastMs=performance.now(), frames=0, lastFpsT=performance.now();
  function frame(){
    const now=performance.now(); const dt=Math.min(0.05, (now-lastMs)/1000); lastMs=now;

    // Movement
    const R = camMatrixNoRoll(yaw,pitch);
    const right={x:R[0],y:R[1],z:R[2]}, up={x:R[3],y:R[4],z:R[5]}, fwd={x:-R[6],y:-R[7],z:-R[8]};
    let dir={x:0,y:0,z:0}; const sprint=(keys['ShiftLeft']||keys['ShiftRight'])?2.0:1.0; const base=3.0*(1+turbo*1.4)*sprint;
    if(keys['KeyW']){ dir.x+=fwd.x; dir.y+=fwd.y; dir.z+=fwd.z; } if(keys['KeyS']){ dir.x-=fwd.x; dir.y-=fwd.y; dir.z-=fwd.z; }
    if(keys['KeyA']){ dir.x-=right.x; dir.y-=right.y; dir.z-=right.z; } if(keys['KeyD']){ dir.x+=right.x; dir.y+=right.y; dir.z+=right.z; }
    if(keys['KeyE']){ dir.x+=up.x; dir.y+=up.y; dir.z+=up.z; } if(keys['KeyQ']){ dir.x-=up.x; dir.y-=up.y; dir.z-=up.z; }
    const L=Math.hypot(dir.x,dir.y,dir.z)||1; dir.x/=L; dir.y/=L; dir.z/=L; pos.x+=dir.x*base*dt; pos.y+=dir.y*base*dt; pos.z+=dir.z*base*dt;

    // Audio values
    const a=getAudio();

    // Pass 1: raymarch to sceneTex
    gl.bindFramebuffer(gl.FRAMEBUFFER, sceneFBO);
    gl.useProgram(progRay);
    gl.uniform2f(uRay.iResolution, canvas.width, canvas.height);
    gl.uniform1f(uRay.iTime, now/1000);
    gl.uniformMatrix3fv(uRay.camR, false, new Float32Array(R));
    gl.uniform3f(uRay.camP, pos.x, pos.y, pos.z);
    gl.uniform1f(uRay.camFov, fov);
    gl.uniform1i(uRay.uShadowOn, toggles.shadow);
    gl.uniform1i(uRay.uAOOn, toggles.ao);
    gl.uniform1i(uRay.uPsycho, toggles.psycho);
    gl.uniform1i(uRay.uLens, toggles.lens);
    gl.uniform1i(uRay.uPauseOrbits, toggles.pauseOrbits);
    gl.uniform1f(uRay.uAudioL, a.low||0);
    gl.uniform1f(uRay.uAudioH, a.hi||0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // Pass 2: downsample + blur
    if(toggles.post){
      gl.bindFramebuffer(gl.FRAMEBUFFER, blurFBOA);
      gl.useProgram(progBlur);
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, sceneTex); gl.uniform1i(uBlur.uTex, 0);
      gl.uniform2f(uBlur.uTexel, 1.0/(canvas.width*0.5), 1.0/(canvas.height*0.5));
      gl.uniform1f(uBlur.uRadius, 2.5);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      gl.bindFramebuffer(gl.FRAMEBUFFER, blurFBOB);
      gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, blurTexA); gl.uniform1i(uBlur.uTex, 0);
      gl.uniform2f(uBlur.uTexel, 1.0/(canvas.width*0.5), 1.0/(canvas.height*0.5));
      gl.uniform1f(uBlur.uRadius, 4.5);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // Pass 3: composite
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.useProgram(progFinal);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, sceneTex); gl.uniform1i(uFin.uScene,0);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, blurTexB); gl.uniform1i(uFin.uBloom,1);
    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, historyTex); gl.uniform1i(uFin.uHistory,2);
    gl.uniform2f(uFin.uRes, canvas.width, canvas.height);
    gl.uniform1f(uFin.iTime, now/1000);
    gl.uniform1f(uFin.camFov, fov);
    gl.uniformMatrix3fv(uFin.camR, false, new Float32Array(R));
    gl.uniform1i(uFin.uBloomOn, toggles.post);
    gl.uniform1i(uFin.uChromAb, toggles.chromab);
    gl.uniform1i(uFin.uGodraysOn, toggles.post);
    gl.uniform1i(uFin.uTrailsOn, toggles.trails);
    gl.uniform1i(uFin.uKaleido, toggles.kaleido);
    gl.uniform1f(uFin.uIntensity, intensity);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // Copy backbuffer to history for trails (fix: use READ/DRAW targets)
    if(toggles.trails){
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, historyFBO);
      gl.blitFramebuffer(0,0,canvas.width,canvas.height, 0,0,canvas.width,canvas.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    }

    // FPS HUD
    frames++; if(now-lastFpsT>500){ fps = frames*1000/(now-lastFpsT); frames=0; lastFpsT=now; drawHUD(); }
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>
</body>
</html>
